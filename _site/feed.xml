<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-07-09T15:44:11+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">개발새발</title><subtitle>A friend who shares is a friend who cares.</subtitle><author><name>박준수</name></author><entry><title type="html">Devops</title><link href="http://localhost:4000/ict/DevOps/" rel="alternate" type="text/html" title="Devops" /><published>2022-07-08T00:00:00+09:00</published><updated>2022-07-08T00:00:00+09:00</updated><id>http://localhost:4000/ict/DevOps</id><content type="html" xml:base="http://localhost:4000/ict/DevOps/"><![CDATA[<h2 id="devops란">DevOps란</h2>

<p><strong>DevOps</strong>란 프로그램 개발 방법론의 하나로 개발자와 운영자와의 협업 및 전환을 빠르게 하기 위한 방법이다.</p>

<blockquote>
  <p>소프트웨어 개발 방법론의 하나로, 개발(development)과 운영(operation)을 결합한 혼성어이다. 개발 담당자와 운영 담당자가 연계하여 협력하는 개발 방법론을 말한다.</p>

  <p>– 두산백과</p>
</blockquote>

<p>전통적인 조직의 경우 개발자부서에서 개발을 하고 운영을 하는 부서가 이를 넘겨 받아 운영을 한다. 개발자들이 시스템 전반적인 지식이 없는 경우 자신이 작성한 프로그램이 로컬에서는 돌아가지만 시스템에 영향을 주거나 정상적인 동작을 하지 못하는 경우가 있었다고 한다.</p>

<p align="center"><img src="/img/ICT/DevOps/devvsops.jpeg" height="100px" width="400px" /></p>

<p>개발부서와 운영부서와의 마찰을 줄이고 능률을 향상 시키기 위해 <strong>DevOps</strong>라는 role이 생기게 되었다. 
<strong>Devops</strong>는 자동화, 협업, 빠른 피드백과 반복적인 개선과정을 통해 개발과 운영의 전환 속도를 빠르게 지원한다.</p>

<h2 id="gitlab">GitLab</h2>

<p>GitLab은 Offline 환경에서도 지원을 해 많은 회사 및 조직에서 사용 중인 서비스다. GitLab에서는 단순 레포지토리로서의 개념이 아닌 운영에도 많은 도움을 주는 관리도구들이 많아 <strong>DevOps</strong>를 구현하는데 좋은 환경이라고 한다.</p>

<h2 id="devops-in-gitlab">DevOps in GitLab</h2>

<p>깃랩에서 DevOps를 어떤 원칙과 방식으로 지원하고 구현하는지 알아보도록 하자.</p>

<h3 id="devops-4대-원칙"><strong>DevOps 4대 원칙</strong></h3>
<ul>
  <li>소프트웨어 개발 생명주기의 자동화</li>
  <li>협동과 소통</li>
  <li>지속적 향상 및 소모 자원의 최소화</li>
  <li>빠른 피드백 주기로 사용자 요구의 집중</li>
</ul>

<p>해당 4대 원칙을 DevOps의 중요 요소로 Gitlab에서는 정의한다. 해당 원칙을 바탕으로 위에서 말한 DevOps의 목표인 개발과 운영간의 전환을 빠르게 한다.</p>

<h3 id="devops-4단계"><strong>DevOps 4단계</strong></h3>

<p>DevOps가 생기며 복잡해지는 경우가 있는데, 이는 두가지 요인 때문이다.</p>

<ul>
  <li>모놀리식 아키텍처에서 MSA(Microservice Architectures)로의 변화</li>
  <li>관리도구와 프로젝트의 증가로 프로젝트 도구의 통합이 필요할 경우.</li>
</ul>

<p>위의 요인을 위한 진화는 4가지 단계로 진행된다.</p>

<p><strong>1. 자신만의 DevOps 구현</strong><br />
   각 팀과 개발자들은 자신만의 DevOps 도구를 선택하게 된다. 이렇게 되면 다른 개발자들 및 팀들과의 협업에서 문제가 생길 수 있는데 이는 다른 팀들이 당신의 도구에 익숙하지 않기 때문이다.</p>

<p><strong>2. Best-in-Class DevOps</strong><br />
   이 단계에서는 서로 다른 도구들을 지양하고, 같은 도구들을 사용하도록 정의한다. DevOps 주기의 각 단계에서 선호하는 하나의 도구를 선택하고 정의함으로 조직간의 협업을 원할히 수행 할 수 있도록 돕는다. 하지만 도구들을 한정적으로 선택하며 소프트웨어를 변경해야되는 문제가 생길 수 있다.</p>

<p><strong>3. DIY DevOps</strong><br />
   위 문제를 해결하기 위해 DIY DevOps 단계를 수행한다. 개발자들은 DevOps 솔루션을 통합하기 위해 다시 개발을 하게 된다. 보통 개발과정에서 다른 개발 도구들과의 통합이나 팀들간의 통합이 고려되지 않기 때문에 해당 과정이 성공적으로 수행되는 경우가 드물다.</p>

<p><strong>4. DevOps Platform</strong><br />
   위에서 사용되는 문제들을 해결하기 위해 단일 어플리케이션 플랫폼<strong>(Gitlab)</strong>이 등장하게 되었다. 개발, 운영, 보안 등 전산 전반에 기여하는 팀들이 사용하는 도구들을 DevOps 주기(계획, 빌드, 보안, 배포)에 맞춰 end-to-end에서 융합 가능한 시스템으로 제공된다. 사용자 친화적인 UI, 융합된 코드 저장소에서 단일 코드 베이스로 제작되어 비효율적이고 신뢰성 낮은 DIY DevOps 환경 보다 신뢰성 높게 동작한다.</p>

<h3 id="devops-생명주기"><strong>DevOps 생명주기</strong></h3>

<p>DevOps 생명주기는 아래의 10단계로 이루어져있다.</p>

<ol>
  <li>관리</li>
  <li>계획</li>
  <li>생성</li>
  <li>검증</li>
  <li>Package</li>
  <li>보안</li>
  <li>배포</li>
  <li>구성</li>
  <li>모니터링</li>
  <li>보호</li>
</ol>

<p>결국 DevOps의 목표는 빠르게 변하는 시장에 맞춰 효율적으로 개발하고 배포하는데 필요없는 소모를 줄이는 것이다.</p>

<h2 id="reference">Reference</h2>

<p><a href="https://about.gitlab.com/topics/devops/#what-is-a-dev-ops-platform">GitLab-What is DevOps</a></p>]]></content><author><name>박준수</name></author><category term="ICT" /><category term="Operation" /><category term="인프라" /><summary type="html"><![CDATA[DevOps란]]></summary></entry><entry><title type="html">클라우드 도입을 위한 핵심 기술</title><link href="http://localhost:4000/cloud/Cloud/" rel="alternate" type="text/html" title="클라우드 도입을 위한 핵심 기술" /><published>2022-06-02T00:00:00+09:00</published><updated>2022-06-02T00:00:00+09:00</updated><id>http://localhost:4000/cloud/Cloud</id><content type="html" xml:base="http://localhost:4000/cloud/Cloud/"><![CDATA[<h2 id="클라우드-도입을-위한-핵심-기술">클라우드 도입을 위한 핵심 기술</h2>

<p>셀프서비스, Pay As You Go, 공유, 신속 제공 및 배포, 이용자의 요구나 수요에 따른 서비스 제공</p>

<p><strong>HOST &amp; Server</strong>
보통이를 혼용해서 사용하는데, 여기서는 HOST는 H/W를 서버를 VM으로 이야기한다.</p>

<p><strong>Pay As You Go</strong> 이용한 만큼 돈을 내는 정책을 말한다.
투자비용이 줄어든다.</p>

<p><strong>DT</strong>의 핵심이 되는 기술 중 하나.
DT의 핵심은 클라우드, 빅데이터, AI.</p>

<p><strong>온프레미스</strong> 사용자가 구축하고 운영하는 것. 자체 구축하고 관리하는 것.</p>

<p><strong>셀프서비스</strong> 논리적으로 HW 등을 구성하고 세팅이 가능하다. POC</p>

<p><strong>Public Cloud:</strong> 불특정다수가 사용할 경우, Online 환경
<strong>Private Cloud:</strong> 특정한 사용자(기업 내 등)만 사용할 경우, Offline 환경
<strong>Hybrid Cloud:</strong> 위 두가지 형태가 혼용</p>

<p>클라우드 환경이 운영 및 구성에 용이함에도 불구하고 기업의 Core System 및 보안정책으로 완전한 클라우드 전환을 하지 않는다.
하지만 기업에서 자체적으로 Private Cloud 환경을 구축해 이를 보완할 수 있다.</p>

<p><strong>가상화</strong> 물리적 IT 리소스를 가상의 IT 리소스로 전환하는 기술
클라우드 이전에 가상화가 이전에 완료되어야 함. 가상화 기술로 가상 머신(VM)을 생성하고 이들은 서로 격리된 상태이다. 서로가 영향을 받지 않는다. 
    1. HOST 가상화: 호스트 OS 위에 하이퍼바이저를 설치한 후 이를 통해 VM 생성 및 관리
    2. 하이퍼바이저(베어메탈) 가상화: 호스트 OS 없이 하이퍼바이저 위에서 VM 생성 및 관리</p>

<p><strong>프로비저닝</strong> 어원은 준비, 예비에서 나왔으나 클라우드에서는 사용자에게 자원 할당 및 정책, 서비스 지원을 의미한다.</p>

<p><strong>클라우드 서비스 운영</strong>
사용자가 자원을 신청 -&gt; 관리자가 자원 관리 -&gt; 사요아작 서비스에 접근 및 이용, 대가 지불</p>

<p><strong>Auto Scaling</strong>
서버가 사용량에 따라 필요시 서버의 자원을 동적으로 관리 가능</p>

<p><strong>IaaS</strong>
HW 자원을 CSP가 제공. 하드웨어, 스토리지, 네트워크 장비들을 임대하는 것</p>

<p><strong>PaaS</strong>
하드웨어 뿐만이 아니라 개발환경까지 CSP한테서 임대하는 것. 애플리케이션 플랫폼에 종속될 수 있다.</p>

<p><strong>SaaS</strong>
구글 드라이브 등과 같이 개발된 소프트웨어를 제공 받는 것</p>

<h1 id="클라우드-서비스-운영-환경">클라우드 서비스 운영 환경</h1>

<h2 id="vmware">VMware</h2>
<p>Console OS 에서 Guest OS 관리
ESX가 Hypervisor 역할을 수행한다.
자원 공유 및 스케줄링 
vCenter: 관리도구
VMware DRS: 리소스를 분산해서 스케쥴링
VMotion: VM을 이동시키는거
HA(High Availblity): 고가용성, HW에 장애 발생시 다른 것으로 넘기는거. Downtime 발생
FT(Fault Tolerant): Downtime이 없는 방법, 다른 호스트에 쉐도우 가상 머신이 생성이되고 운영 호스트가 죽었을 때 쉐도우 가상머신이 올라와서 운영 이관.</p>

<h2 id="openstack">Openstack</h2>

<p><strong>6 Core</strong>
Compute Node: NOVA(Core)
Network Service: Neutron(Core)
Block Storage: Cinder(Core)
Image Storage: Glance(Core)
인증 수단: Keystone(Core)
Object Storage: Swift(Core) -&gt; 이걸로 백업을 받아.</p>

<p><strong>추가 구성 요소</strong>
Dashboard: Horizon
ORCHESTRATION: 템플릿 배포, 앤서블?
KVM 기반이지만 다른 Hypervisor를 수용가능하다. 
Flavor: 템플릿
네트워크 노드(Linux Bridege): VM들은 네트워크 노드를 통해서 나간다. 내부 통신은 OVS를 통해서 진행한다. 따라서 내부통신은 전혀 문제가 없지만 외부와의 통신은 네트워크 노드를 통해서 진행되어 트래픽 과부하가 일어날 수 있다. 이 대안으로 DVR이 나왔다. 가상 라우터를 컴퓨트 노드마다 분산 배치해서 이를 해결한다.</p>

<p><strong>API 기반</strong>
HTTP API, REST API를 통해서 해애 돼.</p>

<p>VMware는 ESXi
MS는 Hyper-V
Linux는 KVM/QEMU
KVM: CPU, Memory 등 H/W를 관여
QEMU: I/O Interface 등 S/W 기반</p>

<p><strong>Leaf/Spine</strong>
앞으로 모든 전산실의 네트워크 구조는 Leaf/Spine 구조로 향하게 될 것이다. 
cyro: 씨앗 창고? SDDC에서는 자원을 저렇게 부르나봐</p>]]></content><author><name>박준수</name></author><category term="Cloud" /><category term="Cloud" /><summary type="html"><![CDATA[클라우드 도입을 위한 핵심 기술]]></summary></entry><entry><title type="html">네트워크 디자인</title><link href="http://localhost:4000/network/Network-design/" rel="alternate" type="text/html" title="네트워크 디자인" /><published>2022-05-29T00:00:00+09:00</published><updated>2022-05-29T00:00:00+09:00</updated><id>http://localhost:4000/network/Network-design</id><content type="html" xml:base="http://localhost:4000/network/Network-design/"><![CDATA[<h2 id="네트워크-디자인">네트워크 디자인</h2>

<h2 id="hierarchical-3-layer">Hierarchical 3 Layer</h2>
<ul>
  <li>Core Layer</li>
  <li>Distributiion Layer</li>
  <li>Access Layer</li>
</ul>

<h2 id="osi-7-layeriso-표준-모델">OSI 7 Layer(ISO 표준 모델)</h2>
<ul>
  <li>Application</li>
  <li>Presentation</li>
  <li>Session</li>
  <li>Transport</li>
  <li>Network</li>
  <li>Data link</li>
  <li>Physical</li>
</ul>

<h2 id="tcpip-model미-국방부">TCP/IP Model(미 국방부)</h2>
<ul>
  <li>Application(HTTP, Telnet, FTP)   : 패킷</li>
  <li>Transport(TCP,UDP) : DST Port 부여</li>
  <li>Network(IPv4, IPv6) : Protocol Number 부여</li>
  <li>Datalink(PPP, Ethernet)   : 네트워크 내부에서 동작, frame, Type Number 부여</li>
  <li>Physical                  : 세그먼트 내부에서 동작
 각 계층별로 헤더를 부여한다. 패킷의 경우 2,3,4 계층의 헤더가 부여된 형태, 4계층의 데이터전송 단위.</li>
</ul>

<p>Novel, Apple, DEC 등 10가지 정도의 프로토콜이 있다.
너무 많으니까 관리자 입장에서는 하나의 프로토콜을 이용하길 원한다.
OSI, TCP/IP의 2가지 프로토콜만 남았다.
TCP/IP 모델만 살아남아 사용을 하고 있다. OSI의 경우에는 상용화가 늦어서 TCP/IP 4계층 모델만 살아남게 되었다.</p>

<h2 id="라우터와-스위치">라우터와 스위치</h2>
<ul>
  <li>
    <p>라우터 
     3계층(IP)를 가지고 매칭
     3계층에서는 라우팅
     2계층에서는 frame Rewrite
     1계층에서는 증폭</p>
  </li>
  <li>
    <p>스위치
     2계층(MAC)을 가지고 매칭
     2계층에서는 스위칭
     1계층에서는 증폭
     FCS 필드를 보고 패킷이 깨진거 확인</p>
  </li>
</ul>

<h2 id="subnet-mask">Subnet Mask</h2>
<p>네트워크와 Host 주소를 나누는 역할.
 해당 주소의 경계 표시 0 ~ 255.255.255.255의 한정적인 주소 범위를 해결하기 위해 서브넷을 나눠 할당해 사용한다. 이도 부족해서 IPv6가 등장하게 되었다. 
 네트워크 주소를 이용해 라우팅 테이블을 설정한다.</p>

<h2 id="패킷의-이동">패킷의 이동</h2>
<p>컴퓨터(APP)에서 가게 되면 장비별로 증폭 및 헤더 부착을 하고 전송</p>

<p>WEB 서버 기준</p>

<p>Client to Server : Request(Get, POST)</p>

<p>Server to Client : Response(200,300,400,500)</p>

<h2 id="ip설계">IP설계</h2>
<ol>
  <li>Subnet Mask 결정</li>
  <li>중복되지 않은 IP 할당</li>
</ol>

<h2 id="tcpudp">TCP/UDP</h2>
<p>TCP: MSS(Max Segment Size) 단위로 자른다.-&gt; 세그먼트 단위로 자른다. 네트워크 공유 가능. 어느 장비에서 보낸 패킷인지 확인 가능
 패킷 단위가 커도 쓸 수 있다.</p>
<ul>
  <li>Sequence #에 맞춰서 조립 가능.</li>
  <li>DST/SRC port가 존재</li>
</ul>

<p>UDP: 세그먼트 단위로 자르지 않는다.
 네트워크 독점한다. 자르지 않을 작은 크기의 패킷이라면 사용하는게 좋다.</p>
<ul>
  <li>Sequence #가 없다.</li>
  <li>DST/SRC port가 존재</li>
</ul>

<p>## TCP Packet</p>
<ul>
  <li>2계층에서 TYPE #</li>
  <li>3계층에서 Protocol #</li>
  <li>4계층에서 DST/SRC port</li>
  <li>Sequence #가 있으면 TCP 없으면 UDP 등의 프로토콜</li>
  <li>Code Bit
    <ol>
      <li>SYN</li>
      <li>ACK : 받았다는 표시</li>
      <li>FIN : 통신 종료</li>
      <li>RST : 비정상적 종료</li>
      <li>PSH : 푸시 비트, 주로 클라이언트의 통신이 끝났을 때 사용</li>
      <li>URG : urgent 비트, 중요 데이터의 위치를 표시</li>
    </ol>
  </li>
  <li>Control Bit
    <ol>
      <li>Error Control : Ack - #</li>
      <li>Flow Control : Window Size(RWND, CWND)
        <ul>
          <li>CWND : 통신이 원할하지 않을 때 보내는 비트 추가 조사 필요. 큰 문제가 있을 경우는 1로 내려가고 작은 문제 3-Ack 등 이 경우에는 cwnd가 1/2로 내려감
3-Ack를 통해 특정 패킷이 깨진것을 확인 가능
            <h2 id="udp">UDP</h2>
          </li>
        </ul>
      </li>
    </ol>
  </li>
  <li>TYPE #</li>
  <li>Protocol #</li>
  <li>DST/SRC port</li>
  <li>Length</li>
  <li>Checksum
 데이터 사이즈 적고 가까운 거리에 client server가 있는경우</li>
</ul>

<p>SYN-ACK 3-way Handshake 과정에서 사용. 
 Connection Oriented(TCP/PPP)
 3-way Handshake 안할 경우 Connection less Protocol(UDP/IP/Ethernet)
 마칠 경우 4-way HandShake 사용</p>]]></content><author><name>박준수</name></author><category term="Network" /><summary type="html"><![CDATA[네트워크 디자인]]></summary></entry><entry><title type="html">Storage</title><link href="http://localhost:4000/ict/Storage/" rel="alternate" type="text/html" title="Storage" /><published>2022-04-17T00:00:00+09:00</published><updated>2022-04-17T00:00:00+09:00</updated><id>http://localhost:4000/ict/Storage</id><content type="html" xml:base="http://localhost:4000/ict/Storage/"><![CDATA[<p>## 스토리지란</p>

<p>스토리지란 직역하자면 <strong>저장 장치</strong>이다. 우리가 사용하는 PC의 경우 PC에 디스크가 있고 해당 위치에 OS, DATA를 저장하고 이를 사용한다.</p>

<p>하지만 DB나 다중 사용자 환경을 지원하는 서버의 경우 가지고 있는 슬롯만으로는 확장성에 한계가 있다. 성능 및 경제적인 문제로 서버는 Compute 용도로만 사용하고 스토리지의 경우 외부 장치를 이용하는 것이 일반적이다.</p>

<p><strong>HCI 및 Composoable</strong> 등 현재 아키텍처에서는 이를 같이 두는 경우도 있다.</p>

<p>스토리지는 다양한 방식으로 나눌 수 있는데 인터페이스(연결방식)에 따라 <strong>DAS, SAN, NAS</strong> 방식으로 나눠진다.</p>

<h2 id="dasdirect-attached-storage">DAS(Direct Attached Storage)</h2>

<p>스토리지 시스템을 <strong>직접(Direct)</strong>로 서버에 붙이는 방식이다. 통상적으로 PC에서 이용하는 외장하드 및 내장하드를 생각하면 이해가 쉽다. 네트워크를 이용하지 않고 IO를 이용해 직접 붙이는 방식이기 때문에 확장성에 한계가 있다.</p>

<h2 id="sanstorage-area-network">SAN(Storage Area Network)</h2>

<p>서버와 호스트간의 <strong>전용 네트워크</strong>를 구성해 이를 연결한다. 기존 네트워크는 NIC를 이용해 구성하는 반면에 SAN은 <strong>HBA</strong> 카드를 이용해 구성한다. 인터페이스 속도도 네트워크의 경우 1G, 10G, 25G, 50G 등으로 구성되는 반면에 HBA의 경우 8G, 16G, 32G 등으로 구성된다.</p>

<p>일반적인 IP Protocol이 아닌 <strong>SCSI Protocol</strong>을 이용하며, <strong>Block</strong> 단위의 IO로 블록 스토리지라고도 한다.</p>

<p><strong>SAN 스위치</strong>를 이용해 서버와 스토리지간 연결한다. SAN 스위치의 경우 <strong>Zoning 구성</strong>을 통해 1:1, 1:N 등 다양한 방식으로 Maaping 가능해 확장성이 높다. 현재 데이터센터에서 사용되는 전통적인 연결방식이다.</p>

<p>블록 스토리지의 경우 정형 데이터를 보관하기가 좋아 DB서버와 많이 사용된다.</p>

<h2 id="nasnetwork-attached-storage">NAS(Network Attached Storage)</h2>

<p><strong>Network</strong>를 이용해 서버와 스토리지를 연결한다. NIC 카드를 이용해 구성되어 서비스 망에 같이 이용할 수도 있고, 사설망으로 따로 구성할 수도 있다.</p>

<p><strong>DAS 및 SAN 스토리지의 경우 파일시스템을 서버가 가지고 있으나, NAS의 경우 파일 시스템을 NAS가 가지고 있어 공유하기가 쉽다.</strong></p>

<p>전통적인 스토리지의 경우 파일 공유가 필요할 경우 스토리지 장비에서 지원하거나 솔루션을 구입해 사용해야 하지만 NAS의 경우에는 추가적인 솔루션이나 기능이 필요가 없다.</p>

<p><strong>FILE I/O</strong> 방식으로 파일 스토리지라고도 불린다. 현재애는 <strong>오브젝트 스토리지</strong>라는 새로운 방식의 스토리지도 등장하며 계속해서 발전하고 있다.</p>

<p>Object 스토리지의 경우 비정형 데이터를 보관하기가 좋아 빅데이터 등의 신기술이 사용되는 도메인에 많이 사용된다고 한다.</p>]]></content><author><name>박준수</name></author><category term="ICT" /><category term="Storage" /><category term="DAS" /><category term="NAS" /><category term="SAN" /><summary type="html"><![CDATA[## 스토리지란]]></summary></entry><entry><title type="html">Server</title><link href="http://localhost:4000/ict/Server/" rel="alternate" type="text/html" title="Server" /><published>2022-04-09T00:00:00+09:00</published><updated>2022-04-17T00:00:00+09:00</updated><id>http://localhost:4000/ict/Server</id><content type="html" xml:base="http://localhost:4000/ict/Server/"><![CDATA[<p>서버란 무엇인가.</p>

<p><strong>사용자들에게 서비스를 제공해 주는 것.</strong></p>

<p><strong>사용자(Client)</strong>들의 요구에 따라서 필요한 서비스를 제공해주는 장비다.</p>

<blockquote>
  <p>어원은 <strong>특정 역할에 특화 된 것</strong>을 의미한다고 한다.</p>
</blockquote>

<p>용도에 따라서 구조가 나눠지는데 크게 <strong>클라이언트-서버 구조</strong>와 <strong>3-tier 구조</strong>로 나눌수 있다.</p>

<h2 id="클라이언트-서버-구조">클라이언트-서버 구조</h2>

<p>사용자(Client)가 <strong>특정 프로그램(Client Program)</strong>을 설치하고 이를 이용해 서버에 접속 해 서버가 제공하는 서비스를 이용한다.</p>

<p>해당 서비스에 기능이 추가되거나 보완이 되는 경우 클라이언트 업데이트가
  필요한 경우도 있다.</p>

<p>이용자가 클라이언트를 업데이트 해야 되는 불편함이 감수되고, 사용자가
 업데이트를 안하고 서비스를 사용한다면 시스템적으로 취약점이 될 수도 있다.</p>

<h2 id="3-tier-구조">3-Tier 구조</h2>

<p>웹 서비스에서 많이 사용 되는 구조로 <strong>프레젠테이션, 애플리케이션, 데이터</strong> 계층으로 이루어져 있다.</p>

<ol>
  <li>
    <p>프레젠테이션 계층</p>

    <p>사용자의 입력을 받고 결과를 표시한다. 웹 서비스에서는 웹 화면을 띄워주는 웹 서버가 해당된다.</p>
  </li>
</ol>

<!--<h2>웹 서버</h2>
&nbsp;기본 APM(Apache(웹 서버), PhP(프로그래밍 언어), MySql(데이터베이스,요즘엔 MariaDB) 이렇게 해서 APM이라고 불린다. 기본이지만 요즘에는 장고(Django) 나 다른 방법으로 구축할 수 있습니다. 요즘엔 Apache 대신 Tomcat을 사용합니다.
 
&nbsp;보통 웹 서버의 경우 리눅스를 이용해서 구축을 많이 하는데 리눅스의 대표적인 특징에는 <strong>쉘</strong>과 <strong>커널</strong>이 있다.

<h2>WAS 서버</h2>
<h2>쉘</h2>
&nbsp;쉘의 경우 사용자와 커널간의 인터페이스이다. 사용자가 명령어를 입력하는 bash 쉘이 대표적이다.
<h2>커널</h2>
&nbsp;커널은 하드웨어의 동작 관리 및 소프트웨어와의 동작을 가능하게 해준다. 커널의 경우 OS의 핵심이라고 할만큼 중요하다. 커널에서 실행되는 프로그램에는 주의가 필요하며 보통 <strong>root</strong> 계정이 커널에 영향을 끼칠 수 가 있어 보안적으로 대비가 필요하다. 
-->]]></content><author><name>박준수</name></author><category term="ICT" /><category term="서버" /><category term="3 계층 구조" /><category term="3-Tier Archtecture" /><summary type="html"><![CDATA[서버란 무엇인가.]]></summary></entry><entry><title type="html">윈도우 기본</title><link href="http://localhost:4000/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/Basic-of-Windows/" rel="alternate" type="text/html" title="윈도우 기본" /><published>2021-02-09T00:00:00+09:00</published><updated>2021-02-09T00:00:00+09:00</updated><id>http://localhost:4000/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/Basic-of-Windows</id><content type="html" xml:base="http://localhost:4000/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/Basic-of-Windows/"><![CDATA[<p>aasss</p>]]></content><author><name>박준수</name></author><category term="정보보안" /><category term="정보보안기사" /><category term="윈도우" /><summary type="html"><![CDATA[aasss]]></summary></entry><entry><title type="html">CSMA/CD</title><link href="http://localhost:4000/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/Network-01/" rel="alternate" type="text/html" title="CSMA/CD" /><published>2020-12-29T00:00:00+09:00</published><updated>2020-12-29T00:00:00+09:00</updated><id>http://localhost:4000/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/Network-01</id><content type="html" xml:base="http://localhost:4000/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/Network-01/"><![CDATA[<p>CSMA/CD 방식에 대해 알아보자.</p>

<h2 id="csmacd">CSMA/CD</h2>
<p><strong>Carrier Sense Multiple Access/Collision Detection</strong>의 약자다.
<strong>Ethernet(이더넷)</strong> 방식의 프로토콜로 통신을 할 때 네트워크상에 통신이 일어나고 있는지를 확인한다. 이를 <strong>Carrier Sense</strong>라고 한다. <strong>Carrier</strong>란 네트워크 상에 나타나는 신호를 의미한다. 네트워크 상에 Carrier가 탐지될 경우 통신이 완료되기까지 기다린다. 네트워크 상에 통신이 일어나지 않을 때, 두 대 이상의 PC 및 서버가 통신을 하고자 데이터를 전송했을 경우 이를 <strong>Multiple Access</strong>라고 한다.
Multiple Access 상황에서는 <strong>Collision(충돌)</strong>이 발생할 수 있다. 따라서 데이터를 전송했을 때 Ethernet의 경우에는 충동이 일어났는지를 확인해야 한다. 이를 <strong>Collision Detection(충돌 감지)</strong>라고 한다. 충돌이 발생했을 경우 각 PC는 랜덤한 시간을 대기한 후 재전송을 하게 되는데 충돌이 지속될 경우에는 통신이 불가능해질 수 있다.</p>]]></content><author><name>박준수</name></author><category term="네트워크" /><summary type="html"><![CDATA[CSMA/CD 방식에 대해 알아보자.]]></summary></entry><entry><title type="html">Snort Rule</title><link href="http://localhost:4000/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/Snort-Rule/" rel="alternate" type="text/html" title="Snort Rule" /><published>2020-12-11T00:00:00+09:00</published><updated>2020-12-11T00:00:00+09:00</updated><id>http://localhost:4000/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/Snort-Rule</id><content type="html" xml:base="http://localhost:4000/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/Snort-Rule/"><![CDATA[<p>Snort에 대해 알아보자.</p>

<h2 id="action">Action</h2>

<ul>
  <li>alert</li>
  <li>log</li>
  <li>pass</li>
  <li>drop</li>
  <li>reject</li>
  <li>sdrop</li>
</ul>

<h2 id="protocol">Protocol</h2>

<ul>
  <li>tcp</li>
  <li>udp</li>
  <li>ip</li>
  <li>icmp</li>
  <li>any</li>
</ul>

<h2 id="방향지정">방향지정</h2>

<ul>
  <li>-&gt;</li>
  <li>&lt;-</li>
  <li>&lt;&gt;</li>
</ul>

<h2 id="일반-옵션">일반 옵션</h2>

<ul>
  <li>msg</li>
  <li>sid</li>
  <li>rev</li>
  <li>priority</li>
  <li>classtype</li>
  <li>reference</li>
</ul>

<p>문법 Action Protocol SrcIP SrcPort -&gt; DstIP DstProt option</p>]]></content><author><name>박준수</name></author><category term="정보보안" /><summary type="html"><![CDATA[Snort에 대해 알아보자.]]></summary></entry><entry><title type="html">SQL Injection</title><link href="http://localhost:4000/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/SQL-Injection/" rel="alternate" type="text/html" title="SQL Injection" /><published>2020-12-07T00:00:00+09:00</published><updated>2020-12-07T00:00:00+09:00</updated><id>http://localhost:4000/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/SQL-Injection</id><content type="html" xml:base="http://localhost:4000/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/SQL-Injection/"><![CDATA[<p>SQL Injection에 대해 알아보자.</p>

<p><strong>SQL Injection</strong>이란 공격자가 SQL 구문을 이용해 서버의 정보를 탈취하거나 인증을 우회하는 공격 기법이다.</p>

<p>SQL Injection에 많이 사용되는 함수들을 알아보자. 밑에 있는 함수들은 주로 MySQL에서 사용되는 함수들이다.</p>

<ul>
  <li>
    <h2 id="user">USER</h2>
    <p><strong>사용자</strong>와 <strong>호스트</strong>를 출력해주는 함수이다. 함수의 형태는 <strong>user()</strong>이고, select user()로 쿼리를 이용해 현재 사용자와 호스트를 출력할 수 있다.</p>
  </li>
  <li>
    <h2 id="version">VERSION</h2>
    <p>현재 <strong>데이터베이스의 버전</strong>을 출력해주는 함수이다. 함수의 형태는 <strong>version()</strong>이고, select version()로 쿼리를 실행해 현재 데이터베이스의 버전을 확인할 수 있다.</p>
  </li>
  <li>
    <h2 id="group_concat">GROUP_CONCAT</h2>
    <p><strong>UNION SELECT</strong>를 이용할 경우 확인할 수 있는 컬럼 수가 제한되는 경우가 많다. 예를 들어 계정 전체를 출력하고 싶은데 출력되는 로우가 하나일 경우 계정 하나 밖에 추출하지 못한다. 이 경우 사용하는 함수가 <strong>group_concat()</strong>이다. SELECT group_concat(name) from users로 쿼리를 돌릴 경우 usres의 name들이 하나의 컬럼으로 합쳐져서 출력된다.</p>
  </li>
</ul>]]></content><author><name>박준수</name></author><category term="정보보안" /><summary type="html"><![CDATA[SQL Injection에 대해 알아보자.]]></summary></entry><entry><title type="html">GNS3 Firewall 실습</title><link href="http://localhost:4000/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/Firewall-in-gns3/" rel="alternate" type="text/html" title="GNS3 Firewall 실습" /><published>2020-12-02T00:00:00+09:00</published><updated>2020-12-02T00:00:00+09:00</updated><id>http://localhost:4000/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/Firewall-in-gns3</id><content type="html" xml:base="http://localhost:4000/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/Firewall-in-gns3/"><![CDATA[<p>GNS3에서 방화벽 Transparent 모드를 실습해 보자.</p>

<h2>Transparent 모드</h2>

<ul>
  <li>방화벽을 2계층에서 동작 시킨다.</li>
  <li>외부에서 봤을 때 홉수가 달라지지 않아 존재를 파악하기 힘들다. -&gt; 보안적으로 뛰어나다?!</li>
  <li>기존 장비들의 IP 주소를 변경시킬 필요가 없다.</li>
  <li>동일한 서브넷 상에서 이동하는 패킷을 검사하고 필터링할 수 있다.</li>
  <li>2계층 트래픽 검사하고 원하지 않는 트래픽 필터링 가능</li>
  <li>관리용 IP가 필요하다</li>
  <li>동적 라우팅 프로토콜을 지원하지 않으며, 수신한 패킷의 목적지 주소가 방화벽의 MAC 주소 테이블에 이씅면 해당 패킷을 전송하고, 존재하지 않을시 ARP를 수행해 MAC를 참조한다.</li>
  <li>컨텍스트?!
이용할시 별개의 네트워크 주소 사용, 동일한 서브넷 이용시 라우터에서 추가 설정 필요, 두 개 이상의 컨텍스에서 하나의 인터페이스 사용 불가.</li>
</ul>

<h2>실습</h2>

<h3 id="1-네트워크-전개">1. <strong>네트워크 전개</strong></h3>
<p><img src="/img/gns3TPFirewall/firewall_tp_network.png" alt="Network Structure" /></p>
<h3 id="2-firewall-설정">2. Firewall 설정</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FW1(config)# firewall transparent
FW1(config)# int bvi 1
FW1(config)# ip add 10.1.12.10 255.255.255.0
FW1(config)# int gi0/0
FW1(config)# bridge-group 1
FW1(config)# nameif inside
FW1(config)# no sh
FW1(config)# int gi0/1
FW1(config)# bridge-group 1
FW1(config)# nameif outside
FW1(config)# no sh
FW1(config)# show bridge-group
</code></pre></div></div>

<p><img src="/img/gns3TPFirewall/firewall_tp_fw1.png" alt="fwimg1" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FW1(config)# show int ip brief
</code></pre></div></div>

<p><img src="/img/gns3TPFirewall/firewall_tp_fw2.png" alt="fwimg2" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FW1(config)# access-list INSIDE-INBOUND permit ip any any
FW1(config)# access-list INSIDE-INBOUND in interface inside
FW1(config)# access-group INSIDE-INBOUND in interface inside
FW1(config)# access-list OUTSIDE-INBOUND permit ospf host 10.1.12.2 any
FW1(config)# access-group OUTSIDE-INBOUND in interface outside
FW1(config)# access-list OUTSIDE-INBOUND permit icmp host 10.1.12.2 host 10.1.12.1
# 이렇게 하면 핑이 갑니다.
# 이게 뭘까..
object network INSIDE-NETWORK
subnet 10.1.12.0 255.255.255.0
nat (inside,outside) dynamic 1.1.1.1
# 10.1.12.0 대역을 1.1.1.1로 변환하는 것. 아펭서는 10.1.12.1 밖에 없으니 1.1.1.1로 다 변환을 하더라도 무리가 없겠죠?
</code></pre></div></div>

<h3 id="3-라우터-설정">3. 라우터 설정</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>R1(config)# router ospf 1
R1(config)# network 10.1.12.1 0.0.0.0 area 0
R1(config)# network 10.1.1.1 0.0.0.0 area 0

R2(config)# ip route 0.0.0.0 0.0.0.0 1.1.23.3
R2(config)# router ospf 1
R2(config)# net 10.1.2.2 0.0.0.0 area 0
R2(config)# net 10.1.12.2 0.0.0.0 area 0
R2(config)# default-information originate

R3(config)# ip route 1.1.1.0 255.255.255.0 1.1.23.2 
# NAT를 하기 위함이래...
R3(config)# line vty 0 4
R3(config)# password cisco
R3(config)# login
# R1에서 telnet으로 R3에 접속하면 R1의 아이피가 1.1.1.1로 바뀌어 오겠지?	
</code></pre></div></div>

<h3 id="4-결과-확인">4. 결과 확인</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FW1(cofig)# show xlate
</code></pre></div></div>
<p><img src="/img/gns3TPFirewall/firewall_tp_fw3.png" alt="fwimg3" /></p>

<h3 id="5-추가-과제">5. 추가 과제</h3>

<p><strong>ARP Spoofing</strong> 막아보기!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FW1(config)# clear configure object
</code></pre></div></div>

<p>기존 정보 삭제</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FW1(config)# arp inside 10.1.12.1 [mac address]
FW1(config)# arp outside 10.1.12.2 [mac address]
</code></pre></div></div>

<p>MAC Address는 라우터에서 show interface를 통해 확인할 수 있습니다.</p>

<p>ex) <code class="language-plaintext highlighter-rouge">R1(config)# do show interface int fa0/0</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> R2(config)# int fa0/0 mac-address 1234.5678.0000
</code></pre></div></div>

<p>R2의 MAC 주소를 수정한 후 R1에서 핑을 날릴 경우 R1의 ARP 테이블이 변경되는 것을 알 수 있습니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> R1(config)# do ping 10.1.12.2
 R1(config)# show arp
</code></pre></div></div>
<p><img src="/img/gns3TPFirewall/firewall_tp_r2.png" alt="rimg1" /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> FW1(config)arp-inspection inside enable
 FW1(config)arp-inspection outside enable no-flood
</code></pre></div></div>

<p><img src="/img/gns3TPFirewall/firewall_tp_fw4.png" alt="fwimg4" /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> R1# clear arp-cache
 R1# show arp
</code></pre></div></div>
<p>show arp로 기존에 지정된 1234.5678.0000이 없어질 때까지 <code class="language-plaintext highlighter-rouge">clear arp-cache</code> 명령어를 반복해주자. 한번에 잘 안된다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>R1# ping 10.1.12.2
</code></pre></div></div>
<p><img src="/img/gns3TPFirewall/firewall_tp_r3.png" alt="rimg1" /></p>

<p>ARP-cache를 초기화 해준뒤 ping을 보내보면 ping이 막힌 것을 볼 수 있다. 지정된 MAC 주소와 현재 R2의 MAC 주소가 달라서 기존에 전송되던 핑이 전송이 되지 않는다. 방화벽에서 inside와 outside의 MAC 주소를 잡아주고 arp-inspection 명령어를 통해 패킷들을 검사하고 OUTSIDE에서 접근하는 패킷의 경우 검사를 통과하지 못하면 no-flood 즉, 통과 시키지 않는다.</p>]]></content><author><name>박준수</name></author><category term="네트워크" /><summary type="html"><![CDATA[GNS3에서 방화벽 Transparent 모드를 실습해 보자.]]></summary></entry></feed>