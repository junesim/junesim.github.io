<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-04-17T14:55:06+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">개발새발</title><subtitle>A friend who shares is a friend who cares.</subtitle><author><name>박준수</name></author><entry><title type="html">Storage</title><link href="http://localhost:4000/ict/Storage/" rel="alternate" type="text/html" title="Storage" /><published>2022-04-17T00:00:00+09:00</published><updated>2022-04-17T00:00:00+09:00</updated><id>http://localhost:4000/ict/Storage</id><content type="html" xml:base="http://localhost:4000/ict/Storage/"><![CDATA[<p>스토리지란 무엇인가.</p>

<p>스토리지란 직역하자면 <strong>저장 장치</strong>이다. 우리가 사용하는 PC의 경우 PC에 디스크가 있고 해당 위치에 OS, DATA를 저장하고 이를 사용한다.</p>

<p>하지만 DB나 다중 사용자 환경을 지원하는 서버의 경우 가지고 있는 슬롯만으로는 확장성에 한계가 있다. 성능 및 경제적인 문제로 서버는 Compute 용도로만 사용하고 스토리지의 경우 외부 장치를 이용하는 것이 일반적이다.</p>

<p><strong>HCI 및 Composoable</strong> 등 현재 아키텍처에서는 이를 같이 두는 경우도 있다.</p>

<p>스토리지는 다양한 방식으로 나눌 수 있는데 인터페이스(연결방식)에 따라 <strong>DAS, SAN, NAS</strong> 방식으로 나눠진다.</p>

<h2 id="dasdirect-attached-storage">DAS(Direct Attached Storage)</h2>

<p>스토리지 시스템을 <strong>직접(Direct)</strong>로 서버에 붙이는 방식이다. 통상적으로 PC에서 이용하는 외장하드 및 내장하드를 생각하면 이해가 쉽다. 네트워크를 이용하지 않고 IO를 이용해 직접 붙이는 방식이기 때문에 확장성에 한계가 있다.</p>

<h2 id="sanstorage-area-network">SAN(Storage Area Network)</h2>

<p>서버와 호스트간의 <strong>전용 네트워크</strong>를 구성해 이를 연결한다. 기존 네트워크는 NIC를 이용해 구성하는 반면에 SAN은 <strong>HBA</strong> 카드를 이용해 구성한다. 인터페이스 속도도 네트워크의 경우 1G, 10G, 25G, 50G 등으로 구성되는 반면에 HBA의 경우 8G, 16G, 32G 등으로 구성된다.
 일반적인 IP Protocol이 아닌 <strong>SCSI Protocol</strong>을 이용하며, <strong>Block</strong> 단위의 IO로 블록 스토리지라고도 한다.</p>

<p><strong>SAN 스위치</strong>를 이용해 서버와 스토리지간 연결한다. SAN 스위치의 경우 <strong>Zoning 구성</strong>을 통해 1:1, 1:N 등 다양한 방식으로 Maaping 가능해 확장성이 높다. 현재 데이터센터에서 사용되는 전통적인 연결방식이다.</p>

<p>블록 스토리지의 경우 정형 데이터를 보관하기가 좋아 DB서버와 많이 사용된다.</p>

<h2 id="nasnetwork-attached-storage">NAS(Network Attached Storage)</h2>

<p><strong>Network</strong>를 이용해 서버와 스토리지를 연결한다. NIC 카드를 이용해 구성되어 서비스 망에 같이 이용할 수도 있고, 사설망으로 따로 구성할 수도 있다.
 <strong>DAS 및 SAN 스토리지의 경우 파일시스템을 서버가 가지고 있으나, NAS의 경우 파일 시스템을 NAS가 가지고 있어 공유하기가 쉽다.</strong> 
 전통적인 스토리지의 경우 파일 공유가 필요할 경우 스토리지 장비에서 지원하거나 솔루션을 구입해 사용해야 하지만 NAS의 경우에는 추가적인 솔루션이나 기능이 필요가 없다.
 <strong>FILE I/O</strong> 방식으로 파일 스토리지라고도 불린다. 현재애는 <strong>오브젝트 스토리지</strong>라는 새로운 방식의 스토리지도 등장하며 계속해서 발전하고 있다.</p>

<p>Object 스토리지의 경우 비정형 데이터를 보관하기가 좋아 빅데이터 등의 신기술이 사용되는 도메인에 많이 사용된다고 한다.</p>]]></content><author><name>박준수</name></author><category term="ICT" /><category term="Storage" /><category term="DAS" /><category term="NAS" /><category term="SAN" /><summary type="html"><![CDATA[스토리지란 무엇인가.]]></summary></entry><entry><title type="html">Server</title><link href="http://localhost:4000/ict/Server/" rel="alternate" type="text/html" title="Server" /><published>2022-04-09T00:00:00+09:00</published><updated>2022-04-17T00:00:00+09:00</updated><id>http://localhost:4000/ict/Server</id><content type="html" xml:base="http://localhost:4000/ict/Server/"><![CDATA[<p>서버란 무엇인가.</p>

<p><strong>사용자들에게 서비스를 제공해 주는 것.</strong></p>

<p><strong>사용자(Client)</strong>들의 요구에 따라서 필요한 서비스를 제공해주는 장비다.</p>

<blockquote>
  <p>어원은 <strong>특정 역할에 특화 된 것</strong>을 의미한다고 한다.</p>
</blockquote>

<p>용도에 따라서 구조가 나눠지는데 크게 <strong>클라이언트-서버 구조</strong>와 <strong>3-tier 구조</strong>로 나눌수 있다.</p>

<h2 id="클라이언트-서버-구조">클라이언트-서버 구조</h2>

<p>사용자(Client)가 <strong>특정 프로그램(Client Program)</strong>을 설치하고 이를 이용해 서버에 접속 해 서버가 제공하는 서비스를 이용한다.</p>

<p>해당 서비스에 기능이 추가되거나 보완이 되는 경우 클라이언트 업데이트가
  필요한 경우도 있다.</p>

<p>이용자가 클라이언트를 업데이트 해야 되는 불편함이 감수되고, 사용자가
 업데이트를 안하고 서비스를 사용한다면 시스템적으로 취약점이 될 수도 있다.</p>

<h2 id="3-tier-구조">3-Tier 구조</h2>

<p>웹 서비스에서 많이 사용 되는 구조로 <strong>프레젠테이션, 애플리케이션, 데이터</strong> 계층으로 이루어져 있다.</p>

<ol>
  <li>
    <p>프레젠테이션 계층</p>

    <p>사용자의 입력을 받고 결과를 표시한다. 웹 서비스에서는 웹 화면을 띄워주는 웹 서버가 해당된다.</p>
  </li>
</ol>

<!--<h2>웹 서버</h2>
&nbsp;기본 APM(Apache(웹 서버), PhP(프로그래밍 언어), MySql(데이터베이스,요즘엔 MariaDB) 이렇게 해서 APM이라고 불린다. 기본이지만 요즘에는 장고(Django) 나 다른 방법으로 구축할 수 있습니다. 요즘엔 Apache 대신 Tomcat을 사용합니다.
 
&nbsp;보통 웹 서버의 경우 리눅스를 이용해서 구축을 많이 하는데 리눅스의 대표적인 특징에는 <strong>쉘</strong>과 <strong>커널</strong>이 있다.

<h2>WAS 서버</h2>
<h2>쉘</h2>
&nbsp;쉘의 경우 사용자와 커널간의 인터페이스이다. 사용자가 명령어를 입력하는 bash 쉘이 대표적이다.
<h2>커널</h2>
&nbsp;커널은 하드웨어의 동작 관리 및 소프트웨어와의 동작을 가능하게 해준다. 커널의 경우 OS의 핵심이라고 할만큼 중요하다. 커널에서 실행되는 프로그램에는 주의가 필요하며 보통 <strong>root</strong> 계정이 커널에 영향을 끼칠 수 가 있어 보안적으로 대비가 필요하다. 
-->]]></content><author><name>박준수</name></author><category term="ICT" /><category term="서버" /><category term="3 계층 구조" /><category term="3-Tier Archtecture" /><summary type="html"><![CDATA[서버란 무엇인가.]]></summary></entry><entry><title type="html">윈도우 기본</title><link href="http://localhost:4000/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/Basic-of-Windows/" rel="alternate" type="text/html" title="윈도우 기본" /><published>2021-02-09T00:00:00+09:00</published><updated>2021-02-09T00:00:00+09:00</updated><id>http://localhost:4000/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/Basic-of-Windows</id><content type="html" xml:base="http://localhost:4000/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/Basic-of-Windows/"><![CDATA[<p>aasss</p>]]></content><author><name>박준수</name></author><category term="정보보안" /><category term="정보보안기사" /><category term="윈도우" /><summary type="html"><![CDATA[aasss]]></summary></entry><entry><title type="html">CSMA/CD</title><link href="http://localhost:4000/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/Network-01/" rel="alternate" type="text/html" title="CSMA/CD" /><published>2020-12-29T00:00:00+09:00</published><updated>2020-12-29T00:00:00+09:00</updated><id>http://localhost:4000/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/Network-01</id><content type="html" xml:base="http://localhost:4000/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/Network-01/"><![CDATA[<p>CSMA/CD 방식에 대해 알아보자.</p>

<h2 id="csmacd">CSMA/CD</h2>
<p><strong>Carrier Sense Multiple Access/Collision Detection</strong>의 약자다.
<strong>Ethernet(이더넷)</strong> 방식의 프로토콜로 통신을 할 때 네트워크상에 통신이 일어나고 있는지를 확인한다. 이를 <strong>Carrier Sense</strong>라고 한다. <strong>Carrier</strong>란 네트워크 상에 나타나는 신호를 의미한다. 네트워크 상에 Carrier가 탐지될 경우 통신이 완료되기까지 기다린다. 네트워크 상에 통신이 일어나지 않을 때, 두 대 이상의 PC 및 서버가 통신을 하고자 데이터를 전송했을 경우 이를 <strong>Multiple Access</strong>라고 한다.
Multiple Access 상황에서는 <strong>Collision(충돌)</strong>이 발생할 수 있다. 따라서 데이터를 전송했을 때 Ethernet의 경우에는 충동이 일어났는지를 확인해야 한다. 이를 <strong>Collision Detection(충돌 감지)</strong>라고 한다. 충돌이 발생했을 경우 각 PC는 랜덤한 시간을 대기한 후 재전송을 하게 되는데 충돌이 지속될 경우에는 통신이 불가능해질 수 있다.</p>]]></content><author><name>박준수</name></author><category term="네트워크" /><summary type="html"><![CDATA[CSMA/CD 방식에 대해 알아보자.]]></summary></entry><entry><title type="html">Snort Rule</title><link href="http://localhost:4000/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/Snort-Rule/" rel="alternate" type="text/html" title="Snort Rule" /><published>2020-12-11T00:00:00+09:00</published><updated>2020-12-11T00:00:00+09:00</updated><id>http://localhost:4000/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/Snort-Rule</id><content type="html" xml:base="http://localhost:4000/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/Snort-Rule/"><![CDATA[<p>Snort에 대해 알아보자.</p>

<h2 id="action">Action</h2>

<ul>
  <li>alert</li>
  <li>log</li>
  <li>pass</li>
  <li>drop</li>
  <li>reject</li>
  <li>sdrop</li>
</ul>

<h2 id="protocol">Protocol</h2>

<ul>
  <li>tcp</li>
  <li>udp</li>
  <li>ip</li>
  <li>icmp</li>
  <li>any</li>
</ul>

<h2 id="방향지정">방향지정</h2>

<ul>
  <li>-&gt;</li>
  <li>&lt;-</li>
  <li>&lt;&gt;</li>
</ul>

<h2 id="일반-옵션">일반 옵션</h2>

<ul>
  <li>msg</li>
  <li>sid</li>
  <li>rev</li>
  <li>priority</li>
  <li>classtype</li>
  <li>reference</li>
</ul>

<p>문법 Action Protocol SrcIP SrcPort -&gt; DstIP DstProt option</p>]]></content><author><name>박준수</name></author><category term="정보보안" /><summary type="html"><![CDATA[Snort에 대해 알아보자.]]></summary></entry><entry><title type="html">SQL Injection</title><link href="http://localhost:4000/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/SQL-Injection/" rel="alternate" type="text/html" title="SQL Injection" /><published>2020-12-07T00:00:00+09:00</published><updated>2020-12-07T00:00:00+09:00</updated><id>http://localhost:4000/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/SQL-Injection</id><content type="html" xml:base="http://localhost:4000/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/SQL-Injection/"><![CDATA[<p>SQL Injection에 대해 알아보자.</p>

<p><strong>SQL Injection</strong>이란 공격자가 SQL 구문을 이용해 서버의 정보를 탈취하거나 인증을 우회하는 공격 기법이다.</p>

<p>SQL Injection에 많이 사용되는 함수들을 알아보자. 밑에 있는 함수들은 주로 MySQL에서 사용되는 함수들이다.</p>

<ul>
  <li>
    <h2 id="user">USER</h2>
    <p><strong>사용자</strong>와 <strong>호스트</strong>를 출력해주는 함수이다. 함수의 형태는 <strong>user()</strong>이고, select user()로 쿼리를 이용해 현재 사용자와 호스트를 출력할 수 있다.</p>
  </li>
  <li>
    <h2 id="version">VERSION</h2>
    <p>현재 <strong>데이터베이스의 버전</strong>을 출력해주는 함수이다. 함수의 형태는 <strong>version()</strong>이고, select version()로 쿼리를 실행해 현재 데이터베이스의 버전을 확인할 수 있다.</p>
  </li>
  <li>
    <h2 id="group_concat">GROUP_CONCAT</h2>
    <p><strong>UNION SELECT</strong>를 이용할 경우 확인할 수 있는 컬럼 수가 제한되는 경우가 많다. 예를 들어 계정 전체를 출력하고 싶은데 출력되는 로우가 하나일 경우 계정 하나 밖에 추출하지 못한다. 이 경우 사용하는 함수가 <strong>group_concat()</strong>이다. SELECT group_concat(name) from users로 쿼리를 돌릴 경우 usres의 name들이 하나의 컬럼으로 합쳐져서 출력된다.</p>
  </li>
</ul>]]></content><author><name>박준수</name></author><category term="정보보안" /><summary type="html"><![CDATA[SQL Injection에 대해 알아보자.]]></summary></entry><entry><title type="html">GNS3 Firewall 실습</title><link href="http://localhost:4000/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/Firewall-in-gns3/" rel="alternate" type="text/html" title="GNS3 Firewall 실습" /><published>2020-12-02T00:00:00+09:00</published><updated>2020-12-02T00:00:00+09:00</updated><id>http://localhost:4000/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/Firewall-in-gns3</id><content type="html" xml:base="http://localhost:4000/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/Firewall-in-gns3/"><![CDATA[<p>GNS3에서 방화벽 Transparent 모드를 실습해 보자.</p>

<h2>Transparent 모드</h2>

<ul>
  <li>방화벽을 2계층에서 동작 시킨다.</li>
  <li>외부에서 봤을 때 홉수가 달라지지 않아 존재를 파악하기 힘들다. -&gt; 보안적으로 뛰어나다?!</li>
  <li>기존 장비들의 IP 주소를 변경시킬 필요가 없다.</li>
  <li>동일한 서브넷 상에서 이동하는 패킷을 검사하고 필터링할 수 있다.</li>
  <li>2계층 트래픽 검사하고 원하지 않는 트래픽 필터링 가능</li>
  <li>관리용 IP가 필요하다</li>
  <li>동적 라우팅 프로토콜을 지원하지 않으며, 수신한 패킷의 목적지 주소가 방화벽의 MAC 주소 테이블에 이씅면 해당 패킷을 전송하고, 존재하지 않을시 ARP를 수행해 MAC를 참조한다.</li>
  <li>컨텍스트?!
이용할시 별개의 네트워크 주소 사용, 동일한 서브넷 이용시 라우터에서 추가 설정 필요, 두 개 이상의 컨텍스에서 하나의 인터페이스 사용 불가.</li>
</ul>

<h2>실습</h2>

<h3 id="1-네트워크-전개">1. <strong>네트워크 전개</strong></h3>
<p><img src="/img/gns3TPFirewall/firewall_tp_network.png" alt="Network Structure" /></p>
<h3 id="2-firewall-설정">2. Firewall 설정</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FW1(config)# firewall transparent
FW1(config)# int bvi 1
FW1(config)# ip add 10.1.12.10 255.255.255.0
FW1(config)# int gi0/0
FW1(config)# bridge-group 1
FW1(config)# nameif inside
FW1(config)# no sh
FW1(config)# int gi0/1
FW1(config)# bridge-group 1
FW1(config)# nameif outside
FW1(config)# no sh
FW1(config)# show bridge-group
</code></pre></div></div>

<p><img src="/img/gns3TPFirewall/firewall_tp_fw1.png" alt="fwimg1" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FW1(config)# show int ip brief
</code></pre></div></div>

<p><img src="/img/gns3TPFirewall/firewall_tp_fw2.png" alt="fwimg2" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FW1(config)# access-list INSIDE-INBOUND permit ip any any
FW1(config)# access-list INSIDE-INBOUND in interface inside
FW1(config)# access-group INSIDE-INBOUND in interface inside
FW1(config)# access-list OUTSIDE-INBOUND permit ospf host 10.1.12.2 any
FW1(config)# access-group OUTSIDE-INBOUND in interface outside
FW1(config)# access-list OUTSIDE-INBOUND permit icmp host 10.1.12.2 host 10.1.12.1
# 이렇게 하면 핑이 갑니다.
# 이게 뭘까..
object network INSIDE-NETWORK
subnet 10.1.12.0 255.255.255.0
nat (inside,outside) dynamic 1.1.1.1
# 10.1.12.0 대역을 1.1.1.1로 변환하는 것. 아펭서는 10.1.12.1 밖에 없으니 1.1.1.1로 다 변환을 하더라도 무리가 없겠죠?
</code></pre></div></div>

<h3 id="3-라우터-설정">3. 라우터 설정</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>R1(config)# router ospf 1
R1(config)# network 10.1.12.1 0.0.0.0 area 0
R1(config)# network 10.1.1.1 0.0.0.0 area 0

R2(config)# ip route 0.0.0.0 0.0.0.0 1.1.23.3
R2(config)# router ospf 1
R2(config)# net 10.1.2.2 0.0.0.0 area 0
R2(config)# net 10.1.12.2 0.0.0.0 area 0
R2(config)# default-information originate

R3(config)# ip route 1.1.1.0 255.255.255.0 1.1.23.2 
# NAT를 하기 위함이래...
R3(config)# line vty 0 4
R3(config)# password cisco
R3(config)# login
# R1에서 telnet으로 R3에 접속하면 R1의 아이피가 1.1.1.1로 바뀌어 오겠지?	
</code></pre></div></div>

<h3 id="4-결과-확인">4. 결과 확인</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FW1(cofig)# show xlate
</code></pre></div></div>
<p><img src="/img/gns3TPFirewall/firewall_tp_fw3.png" alt="fwimg3" /></p>

<h3 id="5-추가-과제">5. 추가 과제</h3>

<p><strong>ARP Spoofing</strong> 막아보기!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FW1(config)# clear configure object
</code></pre></div></div>

<p>기존 정보 삭제</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FW1(config)# arp inside 10.1.12.1 [mac address]
FW1(config)# arp outside 10.1.12.2 [mac address]
</code></pre></div></div>

<p>MAC Address는 라우터에서 show interface를 통해 확인할 수 있습니다.</p>

<p>ex) <code class="language-plaintext highlighter-rouge">R1(config)# do show interface int fa0/0</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> R2(config)# int fa0/0 mac-address 1234.5678.0000
</code></pre></div></div>

<p>R2의 MAC 주소를 수정한 후 R1에서 핑을 날릴 경우 R1의 ARP 테이블이 변경되는 것을 알 수 있습니다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> R1(config)# do ping 10.1.12.2
 R1(config)# show arp
</code></pre></div></div>
<p><img src="/img/gns3TPFirewall/firewall_tp_r2.png" alt="rimg1" /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> FW1(config)arp-inspection inside enable
 FW1(config)arp-inspection outside enable no-flood
</code></pre></div></div>

<p><img src="/img/gns3TPFirewall/firewall_tp_fw4.png" alt="fwimg4" /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> R1# clear arp-cache
 R1# show arp
</code></pre></div></div>
<p>show arp로 기존에 지정된 1234.5678.0000이 없어질 때까지 <code class="language-plaintext highlighter-rouge">clear arp-cache</code> 명령어를 반복해주자. 한번에 잘 안된다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>R1# ping 10.1.12.2
</code></pre></div></div>
<p><img src="/img/gns3TPFirewall/firewall_tp_r3.png" alt="rimg1" /></p>

<p>ARP-cache를 초기화 해준뒤 ping을 보내보면 ping이 막힌 것을 볼 수 있다. 지정된 MAC 주소와 현재 R2의 MAC 주소가 달라서 기존에 전송되던 핑이 전송이 되지 않는다. 방화벽에서 inside와 outside의 MAC 주소를 잡아주고 arp-inspection 명령어를 통해 패킷들을 검사하고 OUTSIDE에서 접근하는 패킷의 경우 검사를 통과하지 못하면 no-flood 즉, 통과 시키지 않는다.</p>]]></content><author><name>박준수</name></author><category term="네트워크" /><summary type="html"><![CDATA[GNS3에서 방화벽 Transparent 모드를 실습해 보자.]]></summary></entry><entry><title type="html">test</title><link href="http://localhost:4000/test/" rel="alternate" type="text/html" title="test" /><published>2020-12-02T00:00:00+09:00</published><updated>2020-12-02T00:00:00+09:00</updated><id>http://localhost:4000/test</id><content type="html" xml:base="http://localhost:4000/test/"><![CDATA[]]></content><author><name>박준수</name></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">IP Class들과 서브넷</title><link href="http://localhost:4000/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/IP-Class/" rel="alternate" type="text/html" title="IP Class들과 서브넷" /><published>2020-11-24T00:00:00+09:00</published><updated>2020-11-24T00:00:00+09:00</updated><id>http://localhost:4000/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/IP-Class</id><content type="html" xml:base="http://localhost:4000/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/IP-Class/"><![CDATA[<p>IP 클래스들에 대해 알아보자.</p>

<p>IP의 경우 5개의 클래스로 이루어져있다. 그리고 클래스 별로 서브넷 마스크가 달라 이에 대한 숙지가 필요하다.</p>

<h2>공인 IP와 사설 IP</h2>
<p><strong>공인 IP</strong>란 전 세계에서 유일한 IP 주소로 ISP가 제공하는 IP 주소이다. 외부에 공개된 주소로 인터넷에 연결된 다른 PC로부터의 접근이 가능하다. 즉 외부 네트워크에 연결하기 위해 필요한 IP로 할당을 하지 못한다.</p>

<p><strong>사설 IP</strong>란 일반 가정 및 회사 등의 할당된 IP 주소로, 로컬 IP라고도 불린다. 개인적인 내부 네트워크에서만 사용 가능한 IP를 의미한다.</p>

<h2>A 클래스</h2>
<p>0.0.0.0 ~ 127.255.255.255
주로 대규모 네트워크에 사용된다. 처음 8비트만이 네트워크 ID에 해당되고 나머지 비트는 호스트 ID에 해당되며 서브넷 마스크는 255.0.0.0
사설 IP의 경우 10.0.0.0 ~ 10.255.255.255</p>
<h2>B 클래스</h2>
<p>128.0.0.0 ~ 191.255.255.255
네트워크 ID는 처음 16비트에 해당되며 서브넷 마스크는 255.255.0.0
사설 IP의 경우 172.16.0.0 ~ 172.31.255.255</p>
<h2>C 클래스</h2>
<p>192.0.0.0 ~ 223.255.255.255
네트워크 ID는 24비트가 해당되고 서브넷 마스크는 255.255.255.0
사설 IP의 경우 192.168.0.0 ~ 192.168.255.255</p>
<h2>D 클래스</h2>
<p>224.0.0.0 ~ 239.255.255.255
멀티캐스트 주소로 예약되어 있고 IP 할당에 이용되지 않는다.</p>
<h2>E 클래스</h2>
<p>240.0.0.0 ~ 255.255.255.255
IANA에서 사용을 허가하지 않은 IP 대역.</p>

<p>네트워크 관리사 문제를 보면 네트워크를 서브넷으로 나누는 문제가 나온다. 어떻게 나눌 수 있는지 알아보자.</p>]]></content><author><name>박준수</name></author><category term="네트워크" /><summary type="html"><![CDATA[IP 클래스들에 대해 알아보자.]]></summary></entry><entry><title type="html">OSI 7계층</title><link href="http://localhost:4000/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/OSI-7-Level/" rel="alternate" type="text/html" title="OSI 7계층" /><published>2020-11-23T00:00:00+09:00</published><updated>2020-11-23T00:00:00+09:00</updated><id>http://localhost:4000/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/OSI-7-Level</id><content type="html" xml:base="http://localhost:4000/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/OSI-7-Level/"><![CDATA[<p>OSI 7계층에 대해 알아보자</p>

<p><strong>물 -&gt; 데 -&gt; 네 -&gt; 전 -&gt; 세 -&gt; 표 -&gt; 응</strong>
물리, 데이터링크, 네트워크, 전송, 세션, 표현, 응용 계층으로 이루어져있다.
이를 OSI 7계층이라고 한다.</p>

<h2 id="물리-계층">물리 계층</h2>
<h2 id="데이터-링크-계층">데이터 링크 계층</h2>
<p>MAC를 이용해서 통신을한다. 흔히 말하는 L2 스튀치의 경우 MAC 주소를 보고 해당 데이터를 어디로 보낼지 검사하는 장비이다. 보안 시스템으로는 L2 방화벽으로 브리지 모드 또는 Transparent Mode라고도 한다. 특성상 IP 주소를 할당할 필요가 없어 인터페이스 모두 같은 IP 주소 대역을 알 수 있고, IP 할당이 필요 없다. <a href="https://junesim.github.io/네트워크/Firewall-in-gns3/">Transparnet 방화벽 실습</a></p>

<h2 id="네트워크-계층">네트워크 계층</h2>
<p>IP 주소와 연관이 깊다.</p>]]></content><author><name>박준수</name></author><category term="네트워크" /><summary type="html"><![CDATA[OSI 7계층에 대해 알아보자]]></summary></entry></feed>